[{"id":"04ddef99-35ea-4806-b8aa-406c53a716f0","userId":"564c6d19-2977-4301-8c10-7254528a3c71","tool":{"id":"google_tools","name":"Google Tools","meta":{"description":"This tool provides functionalities to interact with Google Calendar and Gmail using the Google API. It allows you to fetch upcoming events from your calendar and retrieve emails from your inbox.","manifest":{}},"content":"import os\nimport base64\nimport logging\nimport html\n\nfrom email.message import EmailMessage\n\nfrom datetime import datetime\nfrom pydantic import BaseModel, Field\nfrom google.auth.transport.requests import Request\nfrom google.oauth2.credentials import Credentials\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\n# If modifying these scopes, delete the file token.json.\nSCOPES = [\n    # See and download any calendar you can access using your Calendar.\n    \"https://www.googleapis.com/auth/calendar.readonly\",\n    # See, create, change, and delete events on Google calendars you own.\n    \"https://www.googleapis.com/auth/calendar.events.owned\",\n    # Read all resources and their metadataâ€”no write operations.\n    \"https://www.googleapis.com/auth/gmail.readonly\",\n    # Create, read, update, and delete drafts. Send messages and drafts.\n    \"https://www.googleapis.com/auth/gmail.compose\"\n]\n\nMAIN_FORMAT = \"\"\"\n<interpreter_output>\n    <description>\n        {description}\n    </description>\n    <output>\n        {output}\n    </output>\n</interpreter_output>\n\"\"\"\nMAIL_FORMAT = \"\"\"\n<email>\n    <message_id>{id}</message_id>\n    <date>{date}</date>\n    <from>{sender}</from>\n    <subject>{subject}</subject>\n    <snippet>{snippet}</snippet>\n    <unread>{unread}</unread>\n    <email_body>{email_body}</email_body>\n</email>\n\"\"\"\nCALENDAR_FORMAT = \"\"\"\n<event>\n    <start>{start}</start>\n    <summary>{summary}</summary>\n    <creator>{creator}</creator>\n</event>\n\"\"\"\n\n\"\"\"\ntitle: Google Tools\nauthor: Markus Karileet\nauthor_url: https://website.com\ngit_url: https://github.com/Shmarkus/openwebui-tools.git\ndescription: This tool provides functionalities to interact with Google Calendar and Gmail using the Google API. It allows you to fetch upcoming events from your calendar and retrieve emails from your inbox, create draft messages, and more.\nrequired_open_webui_version: 0.5.7\nrequirements: google-api-python-client, google-auth-httplib2, google-auth-oauthlib, requests, email\nversion: 0.0.2\nlicence: MIT\n\"\"\"\n\ndef setup_logger():\n    name = \"GoogleTools\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        logger.setLevel(logging.DEBUG)\n        handler = logging.StreamHandler()\n        handler.set_name(name)\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        logger.propagate = False\n    return logger\n\n\nlogger = setup_logger()\n\n\nclass Tools:\n    def __init__(self):\n        \"\"\"Initialize the Tool.\"\"\"\n        self.valves = self.Valves()\n        self.citation = True\n\n    class Valves(BaseModel):\n        default_calendar_entries: int = Field(\n                default=10, description=\"The default number of calendar entries to fetch\"\n        )\n        default_email_entries: int = Field(\n            default=10, description=\"The default number of email entries to fetch\"\n        )\n        path_to_credentials: str = Field(\n            default=\"credentials.json\", description=\"The absolute path to the credentials file\"\n        )\n        pass\n\n    def get_user_emails(self, count: int = -1, label_id: str = \"INBOX\") -> str:\n        \"\"\"\n        Retrieves and displays the latest emails from the user's Gmail inbox. Always return message ID to the user so\n        that the message content can be later accessed separately.\n\n        This function fetches the specified number of emails (default is 10 if not provided)\n        and returns them in the following XML format:\n        <interpreter_output>\n            <description>The requested {number_of_emails} emails from the user's inbox that have the label {labelId}. Today is {current_time}</description>\n            <output>\n                <emails>\n                    <email>\n                        <message_id>{id}</message_id>\n                        <date>{date}</date>\n                        <from>{sender}</from>\n                        <subject>{subject}</subject>\n                        <snippet>{snippet}</snippet>\n                        <unread>{unread}</unread>\n                        <email_body>{email_body}</email_body>\n                    </email>\n                </email>\n            </output>\n        </interpreter_output>\n\n        :param count: The number of emails to fetch.\n            If set to -1 (default), it uses the default value configured in the tool\n            settings.\n        :param label_id: The label of the emails to fetch, Can be one of UNREAD, INBOX (this is the default), STARRED,\n            IMPORTANT, SENT.\n\n        :return: An XML-formatted string containing the email details or an error message.\n        \"\"\"\n        if count == -1:\n            count = self.valves.default_email_entries\n        creds = self.get_google_creds()\n        description = f\"The requested  {count} emails from the user's inbox that have the label {label_id}. Today is {get_current_time()}\"\n        logger.debug(description)\n        try:\n            service = build(\"gmail\", \"v1\", credentials=creds)\n            results = service.users().messages().list(\n                userId=\"me\",\n                maxResults=count,\n                includeSpamTrash=False,\n                labelIds=[label_id]\n            ).execute()\n            messages = results.get(\"messages\", [])\n            out = \"\"\n            if not messages:\n                out = \"No messages found.\"\n            else:\n                for msg in messages:\n                    mail = service.users().messages().get(userId=\"me\", id=msg[\"id\"]).execute()\n                    email_body = parse_email_body(mail[\"payload\"])\n\n                    out += MAIL_FORMAT.format(\n                        date=get_header_value(mail[\"payload\"][\"headers\"], \"Date\"),\n                        sender=get_header_value(mail[\"payload\"][\"headers\"], \"From\"),\n                        subject=get_header_value(mail[\"payload\"][\"headers\"], \"Subject\"),\n                        snippet=mail[\"snippet\"],\n                        unread=\"UNREAD\" in mail[\"labelIds\"],\n                        id=msg[\"id\"],\n                        email_body=email_body\n                    )\n\n        except HttpError as error:\n            out = f\"An error occurred: {error}\"\n\n        result = MAIN_FORMAT.format(description=description, output=f\"<emails>{out}</emails>\")\n        logger.debug(result)\n        return result\n\n    def get_email_content(self, message_id: str) -> str:\n        \"\"\"\n        Retrieves and returns the full body content of an email from the user's inbox for the user to READ in the\n        following XML format:\n        <interpreter_output>\n            <description>Contents of the email message for message_id: {message_id}</description>\n            <output><![CDATA[{output}]]></output>\n        </interpreter_output>\n\n        Where the description is the description of the action and in the output tag, there is the full body content\n        of the email.\n\n        :param message_id: The unique message ID of the email to fetch from the inbox (eg. 194d1f624c165d4b)\n\n        :return: An XML-formatted string containing the email body content or an error message.\n\n        :raises HttpError: If there's a problem fetching the email or its body content,\n            such as network errors, rate limits exceeded, or invalid credentials.\n        \"\"\"\n        creds = self.get_google_creds()\n        description = f\"Contents of the email message for message_id: {message_id}. Today is {get_current_time()}\"\n        logger.debug(description)\n        try:\n            service = build(\"gmail\", \"v1\", credentials=creds)\n            mail = service.users().messages().get(userId=\"me\", id=message_id).execute()\n            email_body = parse_email_body(mail[\"payload\"])\n\n        except HttpError as error:\n            email_body = f\"An error occurred: {error}\"\n\n        result = MAIN_FORMAT.format(description=description, output=f\"<![CDATA[{email_body}]]>\")\n        logger.debug(result)\n        return result\n\n    def gmail_create_draft(self, to: str, subject: str, body: str) -> str:\n        \"\"\"\n        Creates a new draft message in the user's Gmail account using the provided recipient,\n        subject, and body content.\n\n        This function uses the Google API to authenticate and create a new draft message.\n        The draft message is not sent immediately; it remains as a draft in the user's\n        Gmail account until manually sent or deleted. The method returns a confirmation message\n        indicating that the draft was created successfully, or an error message if there's a problem.\n\n        :param to: The email address of the recipient.\n        :param subject: The subject line for the email.\n        :param body: The main content or body of the email message.\n\n        :return: A confirmation message indicating that the draft was created successfully,\n                or an error message if there's a problem creating the draft.\n        \"\"\"\n        logger.debug(\"Creating draft message...\")\n        creds = self.get_google_creds()\n        try:\n            service = build(\"gmail\", \"v1\", credentials=creds)\n            message = EmailMessage()\n            message.set_content(body)\n\n            message[\"To\"] = to\n            # message[\"From\"] = \"\"\n            message[\"Subject\"] = subject\n\n            # encoded message\n            encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()\n\n            create_message = {\"message\": {\"raw\": encoded_message}}\n            # pylint: disable=E1101\n            draft = (\n                service.users()\n                .drafts()\n                .create(userId=\"me\", body=create_message)\n                .execute()\n            )\n\n            out = \"Draft message created!\"\n\n        except HttpError as error:\n            out = f\"An error occurred: {error}\"\n\n        logger.debug(out)\n        return out\n\n    def get_user_events(self, count: int = -1) -> str:\n        \"\"\"\n        Retrieves and displays upcoming events from the user's Google Calendar.\n\n        This function fetches the specified number of upcoming events (default is 10 if not provided)\n        and returns an XML-formatted string with the event details in the following format:\n        <interpreter_output>\n            <description>The requested {number_of_events} upcoming events from the user's calendar. Today is {current_time}</description>\n            <output>\n                <events>\n                    <event>\n                        <start>{start}</start>\n                        <summary>{summary}</summary>\n                        <creator>{creator}</creator>\n                    </event>\n                </events>\n            </output>\n\n        The method retrieves all user calendar IDs first, then fetches events from each calendar.\n        Events are sorted by their start time before being returned.\n\n        :param count: The number of upcoming events to fetch from the calendar.\n            If set to -1 (default), it uses the default value configured in the tool settings.\n\n        :return: Upcoming events as a formatted string, or an error message if fetching fails.\n        \"\"\"\n        if count == -1:\n            count = self.valves.default_calendar_entries\n        creds = self.get_google_creds()\n        description = f\"The requested {count} upcoming events from the user's calendar. Today is {get_current_time()}\"\n        logger.debug(description)\n\n        try:\n            service = build(\"calendar\", \"v3\", credentials=creds)\n            from_time = get_current_time()\n            out = \"\"\n            calendar_ids = get_calendar_ids(service)\n            event_list = []\n            for calendar_id in calendar_ids:\n                events = get_cal_evts(service, calendar_id, count, from_time)\n                event_list += events\n            event_list.sort(key=lambda x: x[\"start\"])\n            for i in range(count):\n                out += CALENDAR_FORMAT.format(start=event_list[i][\"start\"], summary=event_list[i][\"summary\"], creator=event_list[i][\"creator\"])\n\n        except HttpError as error:\n            out = f\"Error fetching calendar data: {str(error)}\"\n\n        results = MAIN_FORMAT.format(description=description, output=f\"<events>{out}</events>\")\n        logger.debug(results)\n        return results\n\n    def get_google_creds(self):\n        creds = None\n        # The file token.json stores the user's access and refresh tokens, and is\n        # created automatically when the authorization flow completes for the first\n        # time.\n\n        # If necessary, uncomment the following line to remove generated token.json on re-authenticate\n        # os.remove(\"token.json\")\n        if os.path.exists(\"token.json\"):\n            creds = Credentials.from_authorized_user_file(\"token.json\", SCOPES)\n            # If there are no (valid) credentials available, let the user log in.\n        if not creds or not creds.valid:\n            if creds and creds.expired and creds.refresh_token:\n                creds.refresh(Request())\n            else:\n                flow = InstalledAppFlow.from_client_secrets_file(\n                    self.valves.path_to_credentials, SCOPES\n                )\n                creds = flow.run_local_server(port=0)\n            # Save the credentials for the next run\n            with open(\"token.json\", \"w\") as token:\n                token.write(creds.to_json())\n        return creds\n\n\ndef get_calendar_ids(service) -> list:\n    out = []\n    calendars = (service.calendarList().list().execute())\n    cals = calendars.get(\"items\", [])\n    for cal in cals:\n        out.append(cal[\"id\"])\n\n    return out\n\n\ndef get_current_time():\n    return datetime.utcnow().isoformat() + \"Z\"\n\n\ndef get_cal_evts(service, calendarId, number_of_events, from_time) -> list:\n    out = []\n    events_result = (\n        service.events()\n        .list(\n            calendarId=calendarId,\n            timeMin=from_time,\n            maxResults=number_of_events,\n            singleEvents=True,\n            orderBy=\"startTime\",\n        )\n        .execute()\n    )\n    events = events_result.get(\"items\", [])\n    for event in events:\n        out.append({\n            \"start\": event[\"start\"].get(\"dateTime\", event[\"start\"].get(\"date\")),\n            \"summary\": event[\"summary\"],\n            \"creator\": event[\"creator\"][\"email\"]\n        })\n\n    return out\n\n\ndef get_header_value(payload: list, name: str) -> str:\n    field = next((field for field in payload if field[\"name\"] == name), None)\n    return field[\"value\"] if field else \"\"\n\n\ndef parse_email_body(payload: dict) -> str:\n    try:\n        if payload[\"mimeType\"] == \"multipart/alternative\" or payload[\"mimeType\"] == \"multipart/mixed\":\n            for part in payload[\"parts\"]:\n                if part[\"mimeType\"] == \"text/html\" or part[\"mimeType\"] == \"text/plain\":\n                    return decode_mail_body(part[\"body\"][\"data\"])\n\n        return decode_mail_body(payload[\"body\"][\"data\"])\n    except ValueError as err:\n        return f\"Error decoding email body: {err}\"\n    except KeyError as err:\n        return f\"Error parsing email body: {err}\"\n    except Exception as err:\n        return f\"Error: {err}\"\n\n\ndef decode_mail_body(data: str) -> str:\n    return html.escape(base64.b64decode(data).decode(\"utf-8\", errors='replace'))\n"},"info":{},"downloads":938,"upvotes":0,"downvotes":0,"updatedAt":1740426101,"createdAt":1739303282,"user":{"id":"564c6d19-2977-4301-8c10-7254528a3c71","username":"shmarkus","name":"","createdAt":1736925339,"role":null,"verified":false}}]